<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MiniCool World</title>
    <description>年迈的工程师</description>
    <link>https://minicool.github.io//</link>
    <atom:link href="https://minicool.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 19 Jul 2020 15:34:10 +0800</pubDate>
    <lastBuildDate>Sun, 19 Jul 2020 15:34:10 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>Kubnetes Tls Sertes</title>
        <description>
</description>
        <pubDate>Thu, 23 Aug 2018 00:00:00 +0800</pubDate>
        <link>https://minicool.github.io//2018/08/23/kubnetes-tls-sertes/</link>
        <guid isPermaLink="true">https://minicool.github.io//2018/08/23/kubnetes-tls-sertes/</guid>
        
        
      </item>
    
      <item>
        <title>Network Socat Tool</title>
        <description>
</description>
        <pubDate>Mon, 20 Aug 2018 00:00:00 +0800</pubDate>
        <link>https://minicool.github.io//2018/08/20/network-socat-tool/</link>
        <guid isPermaLink="true">https://minicool.github.io//2018/08/20/network-socat-tool/</guid>
        
        
      </item>
    
      <item>
        <title>Kubenetes Harbor</title>
        <description>
</description>
        <pubDate>Fri, 17 Aug 2018 00:00:00 +0800</pubDate>
        <link>https://minicool.github.io//2018/08/17/kubenetes-harbor/</link>
        <guid isPermaLink="true">https://minicool.github.io//2018/08/17/kubenetes-harbor/</guid>
        
        
      </item>
    
      <item>
        <title>kubenetes RBAC</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在Kubernetes中，授权有ABAC（基于属性的访问控制）、RBAC（基于角色的访问控制）、Webhook、Node、AlwaysDeny（一直拒绝）和AlwaysAllow（一直允许）这6种模式。从1.6版本起，Kubernetes 默认启用RBAC访问控制策略。从1.8开始，RBAC已作为稳定的功能。通过设置–authorization-mode=RBAC，启用RABC。在RABC API中，通过如下的步骤进行授权：1）定义角色：在定义角色时会指定此角色对于资源的访问控制的规则；2）绑定角色：将主体与角色进行绑定，对用户进行访问授权。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;授权主体subject&quot;&gt;授权主体（Subject）&lt;/h3&gt;
&lt;p&gt;RBAC授权中的主体可以是组，用户或者服务帐户。用户通过字符串表示，比如“alice”、 “bob@example.com”等，具体的形式取决于管理员在认证模块中所配置的用户名。system:被保留作为用来Kubernetes系统使用，因此不能作为用户的前缀。组也有认证模块提供，格式与用户类似。&lt;/p&gt;

&lt;h4 id=&quot;用户useraccount&quot;&gt;用户（UserAccount）&lt;/h4&gt;
&lt;p&gt;用户，这是有外部独立服务进行管理的，管理员进行私钥的分配，用户可以使用KeyStone或者Goolge 帐号，甚至一个用户名和密码的文件列表也可以。对于用户的管理集群内部没有一个关联的资源对象，所以用户不能通过集群内部的API 来进行管理&lt;/p&gt;

&lt;p&gt;创建一个只能访问某个 namespace 的用户
namespace:test-ns
username:test-user
group:test-group&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建命名空间“test-user”
command line：命令行&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$kubectl&lt;/span&gt; create namespace test-ns &lt;span class=&quot;c&quot;&gt;#创建命名空间&lt;/span&gt;
namespace &lt;span class=&quot;s2&quot;&gt;&quot;test-ns&quot;&lt;/span&gt; created

&lt;span class=&quot;nv&quot;&gt;$kubectl&lt;/span&gt; get ns                         &lt;span class=&quot;c&quot;&gt;#获取命名空间列表&lt;/span&gt;
NAME           STATUS    AGE
default        Active    9d
test-ns        Active    35s
docker         Active    9d
kube-public    Active    9d
kube-system    Active    9d&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;yaml:格式文件配置&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;c&quot;&gt;#test-ns.yaml&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;test-ns.yaml
apiVersion: v1
kind: Namespace
metadata:
 name: test-ns

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; test-ns.ymal
namespace &lt;span class=&quot;s2&quot;&gt;&quot;test-ns&quot;&lt;/span&gt; created &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;创建用户凭证
Kubernetes没有User Account的API 对象，不过要创建一个用户帐号的话也是挺简单的，利用管理员分配的一个私钥就可以创建了。
在此利用openssl来创建，创建私钥，命名为wolken.key&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(1)使用openssl创建私钥&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;openssl genrsa &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; test-user.key 2048&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(2)使用私钥创建证书签名请求文件
使用刚刚创建的私钥创建一个证书签名请求文件：test-user.csr，要注意需要确保在-subj参数中指定用户名和组(CN表示用户名，O表示组)：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;openssl req &lt;span class=&quot;nt&quot;&gt;-new&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-key&lt;/span&gt; test-user.key &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; test-user.csr &lt;span class=&quot;nt&quot;&gt;-subj&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/CN=test-user/O=test-group&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(3)使用Kubernetes集群的授权创建的证书请求
然后找到Kubernetes集群的CA，
kubeadm安装的集群，CA相关证书位于/etc/kubernetes/pki/目录下面，
二进制方式搭建的，应该在最开始搭建集群的时候就已经指定好了CA的目录(/data/kubernetes/ssl)，
然后利用该目录下面的ca.crt和ca.key两个文件来批准上面的证书请求。
找到kubernetes集群认证中心，位置通常在/etc/kubernetes/pki，检查是否存在ca.crt、ca.key。生成最终的证书test-user.crt，有效期30天。&lt;/p&gt;

&lt;p&gt;openssl x509 -req -in test-user.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out test-user.crt -days 30
到此凭证已经可用。可直接在kubeconfig中指定client-certificate与client-key文件位置。但是我需要在本地机器连接该账号。于是将wolken.crt与wolken.key转为base64。通过client-certificate-data与client-key-data配置。&lt;/p&gt;

&lt;p&gt;(4)生成凭证及上下文
现在可以使用刚刚创建的证书文件和私钥文件在集群中创建新的凭证和上下文(Context):&lt;/p&gt;

&lt;p&gt;创建用户凭证&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl config set-credentials test-user-cre &lt;span class=&quot;nt&quot;&gt;--client-certificate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;test-user.crt  &lt;span class=&quot;nt&quot;&gt;--client-key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;test-user.key&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;用户凭证也可以通过certificate-data及key-data写入&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;test-user.crt|base64 &lt;span class=&quot;nt&quot;&gt;--wrap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0  &lt;span class=&quot;c&quot;&gt;#获取base64位test-user.crt&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;test-user.key|base64 &lt;span class=&quot;nt&quot;&gt;--wrap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0  &lt;span class=&quot;c&quot;&gt;#获取base64位test-user.key&lt;/span&gt;
将输出写进kubeconfig，或者通过命令创建用户，将上面的输出替换对应位置&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;CRT_BASE64&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;与&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;KEY_BASE64&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
kubectl config set-credentials test-user-cre &lt;span class=&quot;nt&quot;&gt;--client-certificate-data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;={&lt;/span&gt;CRT_BASE64&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;--client-key-data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;={&lt;/span&gt;KEY_BASE64&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;创建该用户新的Context:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl config set-context test-user-context &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kubernetes &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;test-user &lt;span class=&quot;nt&quot;&gt;--user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;test-user-cre&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;检测上下文:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl &lt;span class=&quot;nt&quot;&gt;--context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;test-user-context get pods
Error from server &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Forbidden&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: pods is forbidden: User &lt;span class=&quot;s2&quot;&gt;&quot;test-user-cre&quot;&lt;/span&gt; cannot list pods &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the namespace &lt;span class=&quot;s2&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;会发现请求被forbidden，是因为没有配置权限给test-user。&lt;/p&gt;

&lt;p&gt;按照现有环境配置，k8s 组件访问 apiserver 使用基于证书的认证方式，apiserver 接受请求时会从client 证书中提取
CN、O字段，分别作为 subjects 中的 User 和 Group&lt;/p&gt;

&lt;h4 id=&quot;用户组group&quot;&gt;用户组（Group）&lt;/h4&gt;
&lt;p&gt;用来关联多个账户的，集群中有一些默认创建的组，比如cluster-admin&lt;/p&gt;

&lt;h4 id=&quot;服务账户service-account&quot;&gt;服务账户（Service Account）&lt;/h4&gt;
&lt;p&gt;通过Kubernetes API 来管理的一些用户帐号，和namespace 进行关联的，适用于集群内部运行的应用程序，需要通过API 来完成权限认证，所以在集群内部进行权限操作，都需要使用到 ServiceAccount&lt;/p&gt;

&lt;h3 id=&quot;规则rule&quot;&gt;规则（Rule）&lt;/h3&gt;
&lt;p&gt;Kubernetes有一个很基本的特性就是它的所有资源对象都是模型化的 API 对象，允许执行 CRUD(Create、Read、Update、Delete)操作(也就是我们常说的增、删、改、查操作)，比如下面的这下资源：&lt;/p&gt;

&lt;p&gt;resourse:
Pods、
Nodes、
Services、
Deployment、
Replicasets、
Statefulsets、
Namespace、
Persistents、
Secrets和ConfigMaps
上面这些资源对象的可能存在的操作有：&lt;/p&gt;

&lt;p&gt;verbs:
create
get
delete
list
update
edit
watch
exec
在更上层，这些资源和API Group 进行关联，比如Pods属于Core API Group，而Deployements属于 apps API Group，&lt;/p&gt;

&lt;h3 id=&quot;角色和集群角色-role--clusterrole&quot;&gt;角色和集群角色 (Role &amp;amp; ClusterRole)&lt;/h3&gt;
&lt;p&gt;在RBAC API中，角色包含代表权限集合的规则。在这里，权限只有被授予，而没有被拒绝的设置。在Kubernetes中有两类角色，即普通角色和集群角色。可以通过Role定义在一个命名空间中的角色，或者可以使用ClusterRole定义集群范围的角色。&lt;/p&gt;

&lt;p&gt;Role 和 ClusterRole：角色和集群角色，这两个对象都包含上面的Rules 元素，二者的区别在于，在Role 中，定义的规则只适用于单个命名空间，也就是和namespace 关联的，而ClusterRole 是集群范围内的，因此定义的规则不受命名空间的约束。另外Role和 ClusterRole在Kubernetes中都被定义为集群内部的API 资源，和Pod、ConfigMap 这些类似，都是集群的资源对象，所以同样的可以使用kubectl相关的命令来进行操作&lt;/p&gt;

&lt;h4 id=&quot;角色role&quot;&gt;角色(Role)&lt;/h4&gt;
&lt;p&gt;一个角色只能被用来授予访问单一命令空间中的资源。一般来说角色都是被限定在某个命名空间中。&lt;/p&gt;

&lt;p&gt;example: 
“default”命令空间中定义了一个名为“pod-reader”的角色，此角色能够对在“default”命名空间中访问Pod：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查询role角色在”default”命名空间 或者查询所有命名空间&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$kubectl&lt;/span&gt; get roles &lt;span class=&quot;nt&quot;&gt;--namespace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;default

&lt;span class=&quot;nv&quot;&gt;$kubectl&lt;/span&gt; get roles &lt;span class=&quot;nt&quot;&gt;--all-namespaces&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;创建角色信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;yaml格式载入&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;s&quot;&gt;$ cat test-pod-reader-role.yaml&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Role&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-ns&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-pod-reader&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiGroups&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &quot;&quot; indicates the core API group&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;pods&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;resourceNames&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;readablepod&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;anotherpod&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;verbs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;get&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;watch&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;list&quot;&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;$kubectl create -f create-role.yaml&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;命令行&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#标准语法&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;$ role NAME --verb=verb --resource=resource.group/subresource [--resource-name=resourcename] [--dry-run]&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;$ kubectl create role test-pod-reader --verb=get,list,watch --resource=pods --resource-name=readablepod --resource-name=anotherpod --namespace=test-ns&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;集群角色clusterrole&quot;&gt;集群角色(ClusterRole)&lt;/h4&gt;

&lt;p&gt;集群角色(ClusterRole)能够被授予如下资源的权限：&lt;/p&gt;

&lt;p&gt;集群范围的资源（类似于Node）
非资源端点（类似于”/healthz”）
集群中所有命名空间的资源（类似Pod）
下面是授予集群角色读取秘密字典文件访问权限的例子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查询clusterrole角色&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$kubectl&lt;/span&gt; get clusterrole&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;创建集群角色
yaml格式&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#test-clusterrole.yaml&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;kind:ClusterRole&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;apiVersion:rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# &quot;namespace&quot; omitted since ClusterRoles are not namespaced&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:test-clusterrole-secret-reader&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apiGroups:[&quot;&quot;]&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;resources:[&quot;secrets&quot;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#明确资源类型&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;verbs:[&quot;get&quot;,&quot;watch&quot;,&quot;list&quot;]&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;$ kubectl create -f test-clusterrole.yaml&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;命令行&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;s&quot;&gt;$ clusterrole NAME --verb=verb --resource=resource.group [--resource-name=resourcename] [--dry-run]&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;$ kubectl create role test-pod-reader\&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;--verb=get,list,watch\&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;--resource=secrets&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;角色绑定和集群角色绑定rolebinding--clusterrolebinding&quot;&gt;角色绑定和集群角色绑定(RoleBinding &amp;amp; ClusterRoleBinding)&lt;/h3&gt;
&lt;p&gt;角色绑定用于将角色与一个或一组用户进行绑定，从而实现将对用户进行授权的目的。主体分为用户、组和服务帐户。角色绑定也分为角色普通角色绑定和集群角色绑定。
角色绑定和集群角色绑定，简单来说就是把声明的Subject和Role 进行绑定的过程(给某个用户绑定上操作的权限)，二者的区别也是作用范围的区别：RoleBinding只会影响到当前namespace 下面的资源操作权限，而ClusterRoleBinding会影响到所有的 namespace。&lt;/p&gt;

&lt;h4 id=&quot;角色绑定-rolebinding&quot;&gt;角色绑定 (RoleBinding)&lt;/h4&gt;
&lt;p&gt;角色绑定只能引用同一个命名空间下的角色。在下面的例子中，在”default”命名空间中角色绑定将‘jane’用户和“pod-reader”角色进行了绑定，这就授予了“jane”能够访问“default”命名空间下的Pod。&lt;/p&gt;

&lt;p&gt;RoleBinding既可以引用相同namespace下的Role；又可以引用一个ClusterRole，RoleBinding引用ClusterRole时用户继承的权限会被限制在RoleBinding所在的namespace下。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;yaml 文件创建&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#test-rolebinging.yaml&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# This role binding allows &quot;jane&quot; to read pods in the &quot;default&quot; namespace.&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;kind:RoleBinding&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;apiVersion:rbac.authorization.k8s.io/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:read-pods&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;namespace:test-user&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#主体&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:User&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:test-user-csr&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;roleRef&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#引用的角色&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;kind:Role&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:test-role&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;命令行创建&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;s&quot;&gt;$ rolebinding NAME --clusterrole=NAME|--role=NAME [--user=username] [--group=groupname] [--serviceaccount=namespace:serviceaccountname] [--dry-run]&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;kubectl create rolebinding read-pods \&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;--role=test-role \&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;--user=test-user-csr \&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;--user=test-user-csr1 \&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;--group=test-user-group&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;集群角色绑定&quot;&gt;集群角色绑定&lt;/h4&gt;

&lt;p&gt;1.查询&lt;/p&gt;

&lt;p&gt;名称为 “alice@example.com”用户：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:User&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:&quot;alice@example.com&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;名称为“frontend-admins”的组：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:&quot;frontend-admins&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在kube-system命名空间中，名称为“default”的服务帐户：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:ServiceAccount&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:default&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;namespace:kube-system&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;在“qa”命名空间中，所有的服务帐户：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:system:serviceaccounts:qa&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所有的服务帐户：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:system:serviceaccounts&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所有被认证的用户 (version 1.5+):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:system:authenticated&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所有未被认证的用户 (version 1.5+):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:system:unauthenticated&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;所有用户(version 1.5+):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span class=&quot;na&quot;&gt;subjects&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:system:authenticated&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kind:Group&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;name:system:unauthenticated&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;apiGroup:rbac.authorization.k8s.io&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;cfssl-创建用户私钥及凭证&quot;&gt;cfssl 创建用户私钥及凭证&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;安装cfssl
$brew install cfssl&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;kubenetes-config&quot;&gt;kubenetes config&lt;/h4&gt;
</description>
        <pubDate>Fri, 10 Aug 2018 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/10/kubenetes-RBAC/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/10/kubenetes-RBAC/</guid>
        
        <category>kubentes</category>
        
        <category>RBAC</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>kubenetes-fabric8</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;fabric8是一个开源集成开发平台，为基于Kubernetes和Jenkins的微服务提供持续发布。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;h4 id=&quot;mac平台&quot;&gt;mac平台&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;使用howbrew安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$ brew install gofabric8&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动gofabric8 
$ gofabric8 deploy -y -domain=wangzhenhua.com –namespace=fabric8&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;验证安装情况
$ gofabric8 validate
$ gofabric8 volumes&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请注意，这里我们需要把RBAC关掉&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$ kubectl create clusterrolebinding permissive-binding –clusterrole=cluster-admin –user=admin –user=kubelet –group=system:serviceaccounts&lt;/p&gt;

&lt;h4 id=&quot;k8s集群&quot;&gt;k8s集群&lt;/h4&gt;
&lt;p&gt;安装好了kube-dns和ingress-controller组件，和helm工具。&lt;/p&gt;

&lt;p&gt;1.添加helm源
helm repo add fabric8 https://fabric8.io/helm&lt;/p&gt;

&lt;p&gt;2.下载官方模版
$ helm fetch fabric8/fabric8-platform
$ tar -xvf fabric8-platform-2.4.24-helm.tar.gz&lt;/p&gt;

&lt;p&gt;3.对模版进行配置及修改&lt;/p&gt;

&lt;p&gt;2.使用官方提供模版,现阶段需要翻墙 国内没有找到对应镜像
helm install fabric8/fabric8-platform –name fabric8-platform&lt;/p&gt;

&lt;p&gt;自动安装一堆的deployment、PersistentVolumeClaim和ConfigMap； 
在提供足够的PersistentVolume，并根据实际情况修改好必要的ConfigMap之前，大部分组件是不可能正常运行的。&lt;/p&gt;

&lt;p&gt;3.
cat «EOF | kubectl apply -f -
apiVersion: “v1”
data:
  config.yml: |-
    exposer: “Ingress”
    domain: “minicool.local”
kind: “ConfigMap”
metadata:
  name: “exposecontroller”
EOF&lt;/p&gt;

</description>
        <pubDate>Tue, 07 Aug 2018 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/kubenetes-fabric8/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/kubenetes-fabric8/</guid>
        
        <category>kubentes</category>
        
        <category>fabric8</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>helm-charts</title>
        <description>&lt;p&gt;###&lt;/p&gt;

&lt;p&gt;###&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Aug 2018 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/helm-charts/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/helm-charts/</guid>
        
        <category>kubentes</category>
        
        <category>helm</category>
        
        <category>charts</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>helm-repo-svc</title>
        <description>&lt;p&gt;###helm-svc 搭建本地repo&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;helm 创建repo目录
$helm mkdir -p /usr/local-repo /usr/local-repo/charts&lt;/li&gt;
  &lt;li&gt;helm 启动svc服务
helm serve –address 0.0.0.0:8879 –repo-path /usr/local-repo&lt;/li&gt;
  &lt;li&gt;helm 添加repo
helm repo add local-repo http://192.168.1.13:8879/charts  #0.0.0.0:8879&lt;/li&gt;
  &lt;li&gt;helm 查看repo
helm repo list
NAME    URL
local   http://127.0.0.1:8879/charts
aliyun  https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;github-搭建hub-repo&quot;&gt;github 搭建hub-repo&lt;/h3&gt;

&lt;h3 id=&quot;google云端存储gcs&quot;&gt;Google云端存储（GCS）&lt;/h3&gt;

&lt;h3 id=&quot;amazon-s3&quot;&gt;Amazon S3&lt;/h3&gt;

&lt;h3 id=&quot;artifactory&quot;&gt;Artifactory&lt;/h3&gt;
</description>
        <pubDate>Tue, 07 Aug 2018 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/hlem-repo-svc/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/hlem-repo-svc/</guid>
        
        <category>kubentes</category>
        
        <category>helm</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>kubenetes-helm</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Helm是目前Kubernetes服务编排领域的唯一开源子项目，做为Kubernetes应用的一个包管理工具，可理解为Kubernetes的apt-get / yum，由Deis 公司发起，该公司已经被微软收购。Helm通过软件打包的形式，支持发布的版本管理和控制，很大程度上简化了Kubernetes应用部署和管理的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Helm产生原因
利用Kubernetes部署一个应用，需要Kubernetes原生资源文件如deployment、replicationcontroller、service或pod 等。而对于一个复杂的应用，会有很多类似上面的资源描述文件，如果有更新或回滚应用的需求，可能要修改和维护所涉及的大量资源文件，且由于缺少对发布过的应用版本管理和控制，使Kubernetes上的应用维护和更新等面临诸多的挑战，而Helm可以帮我们解决这些问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Helm主要处理Kubernetes应用编排中资源文件管理工作。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;管理、编辑与更新大量的K8s配置文件&lt;/li&gt;
    &lt;li&gt;部署一个含有大量配置文件的复杂K8s应用&lt;/li&gt;
    &lt;li&gt;分享和复用K8s配置和应用&lt;/li&gt;
    &lt;li&gt;参数化配置模板支持多个环境&lt;/li&gt;
    &lt;li&gt;管理应用的发布：回滚、diff和查看发布历史&lt;/li&gt;
    &lt;li&gt;控制一个部署周期中的某一些环节&lt;/li&gt;
    &lt;li&gt;发布后的验证&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;###重要概念：
chart：包含了创建Kubernetes的一个应用实例的必要信息
config：包含了应用发布配置信息
release：是一个chart及其配置的一个运行实例&lt;/p&gt;

&lt;p&gt;###基本构架
helm主要由helm client 和 tiler server 组成。&lt;/p&gt;

&lt;p&gt;1.helm [go编写 开源]
helm客户端是一个命令行工具，负责管理charts、reprepository和release。它通过gPRC API（使用kubectl port-forward将tiller的端口映射到本地，然后再通过映射后的端口跟tiller通信）向tiller发送请求，并由tiller来管理对应的Kubernetes资源。
Helm客户端的使用方法参见Helm命令。
(1)仓库管理
(2)本地chart开发
(3)与Tiller sever交互
(4)发送预安装的chart
(5)查询release信息
(6)要求升级或卸载已存在的release&lt;/p&gt;

&lt;p&gt;2.tiller [go编写 开源]
tiller接收来自helm客户端的请求，并把相关资源的操作发送到Kubernetes，负责管理（安装、查询、升级或删除等）和跟踪Kubernetes资源。为了方便管理，tiller(自身没有数据库)把release的相关信息保存在kubernetes的ConfigMap中。
tiller对外暴露gRPC API，供helm客户端调用。
(1)监听来自Helm client的请求
(2)通过chart及其配置构建一次发布
(3)安装chart到Kubernetes集群，并跟踪随后的发布
(4)通过与Kubernetes交互升级或卸载chart&lt;/p&gt;

&lt;p&gt;3.Repository 是 Chart 仓库，Helm客户端通过HTTP协议来访问仓库中Chart的索引文件和压缩包。&lt;/p&gt;

&lt;p&gt;###Helm通信原理
Helm过程&lt;/p&gt;

&lt;p&gt;Chart Install 过程：
Helm从指定的目录或者tgz文件中解析出Chart结构信息
Helm将指定的Chart结构和Values信息通过gRPC传递给Tiller
Tiller根据Chart和Values生成一个Release
Tiller将Release发送给Kubernetes用于生成Release&lt;/p&gt;

&lt;p&gt;Chart Update过程：
Helm从指定的目录或者tgz文件中解析出Chart结构信息
Helm将要更新的Release的名称和Chart结构，Values信息传递给Tiller
Tiller生成Release并更新指定名称的Release的History
Tiller将Release发送给Kubernetes用于更新Release&lt;/p&gt;

&lt;p&gt;Chart Rollback过程：
Helm将要回滚的Release的名称传递给Tiller
Tiller根据Release的名称查找History
Tiller从History中获取上一个Release
Tiller将上一个Release发送给Kubernetes用于替换当前Release&lt;/p&gt;

&lt;p&gt;Chart依赖说明： 
Tiller在处理Chart时，直接将Chart以及其依赖的所有Charts合并为一个Release，同时传递给Kubernetes。因此Tiller并不负责管理依赖之间的启动顺序。Chart中的应用需要能够自行处理依赖关系。&lt;/p&gt;

&lt;h4 id=&quot;前期准备工作&quot;&gt;前期准备工作&lt;/h4&gt;

&lt;h3 id=&quot;安装方式&quot;&gt;安装方式&lt;/h3&gt;
&lt;h4 id=&quot;helm-client安装&quot;&gt;Helm Client安装&lt;/h4&gt;
&lt;p&gt;1.brew 安装
$brew install kubenetes-helm&lt;/p&gt;

&lt;p&gt;2.tar包 安装
github: https://github.com/kubernetes/helm/releases
下载 Helm 2.6.1：
https://storage.googleapis.com/kubernetes-helm/helm-v2.9.1-linux-amd64.tar.gz
解包：
tar -zxvf helm-v2.9.1-linux-amd64.tgz
helm二进制文件移到/usr/local/bin目录：
mv linux-amd64/helm /usr/local/bin/helm&lt;/p&gt;

&lt;h4 id=&quot;helm-tiller安装&quot;&gt;Helm Tiller安装&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Helm Tiller安装
Helm Tiller是Helm的server，用来管理release。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Tiller有多种安装方式，比如本地安装或以pod形式部署到Kubernetes集群中。本文以pod安装为例，安装Tiller的最简单方式是helm init, 该命令会检查helm本地环境设置是否正确，helm init会连接kubectl默认连接的kubernetes集群（可以通过kubectl config view查看），一旦连接集群成功，tiller会被安装到kube-system namespace中。&lt;/p&gt;

&lt;p&gt;执行helm init 
该命令会通过Kubernetes的Deployment 部署tiller，并且在本机配置一个名为local的本地repo，当前用户目录下会生成.helm文件夹（即~/.helm）放置repo相关内容。
————————————-
helm init主要做了以下三件事情：&lt;/p&gt;

&lt;p&gt;部署Tiller
初始化本地 cache
初始化本地 chart仓库&lt;/p&gt;

&lt;h3 id=&quot;定义配置部署&quot;&gt;定义配置部署&lt;/h3&gt;
&lt;p&gt;&amp;lt;1&amp;gt;为了起在指定节点上和使用已有镜像，我修改了tiller的deployment： 
kubectl edit deployment tiller-deploy -n kube-system&lt;/p&gt;

&lt;p&gt;image: registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.9.1
  nodeSelector:
    node-role.kubernetes.io/master: “true”
  tolerations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;key: node-role.kubernetes.io/master
effect: NoSchedule&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;2&amp;gt;修改tiller的svc使其暴露nodePort端口： 
kubectl edit svc tiller-deploy -n kube-system&lt;/p&gt;

&lt;p&gt;ports:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;name: tiller
nodePort: 32134
  type: NodePort&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;3&amp;gt;Tiller还可以通过指定启动参数的形式修改这些配置：&lt;/p&gt;

&lt;p&gt;安装金丝雀build： –canary-image
安装指定image：–tiller-image
指定某一个Kubernetes集群：–kube-context
指定namespace安装：–tiller-namespace&lt;/p&gt;

&lt;p&gt;helm init –tiller-image=daocloud.io/liukuan73/tiller-lk:v2.9.1 –tiller-namespace=kube-system&lt;/p&gt;

&lt;p&gt;&amp;lt;4&amp;gt; Helm TILLER删除 
由于 Tiller的数据存储于Kubernetes ConfigMap中，所以删除、升降级Tiller，原Helm部署的应用数据并不会丢失。 
删除Tiller：&lt;/p&gt;

&lt;p&gt;helm reset&lt;/p&gt;

&lt;h3 id=&quot;rbac配置补充&quot;&gt;RBAC配置补充&lt;/h3&gt;
&lt;p&gt;如果启用的RBAC（Role-Based Access Control），在 helm init 时指定sa&lt;/p&gt;
&lt;h3 id=&quot;命令行&quot;&gt;命令行&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;创建sa
kubectl create serviceaccount –namespace kube-system tiller&lt;/li&gt;
  &lt;li&gt;给sa绑定cluster-admin规则
kubectl create clusterrolebinding tiller-cluster-rule –clusterrole=cluster-admin –serviceaccount=kube-system:tiller&lt;/li&gt;
  &lt;li&gt;编辑 Tiller Deployment 名称为： tiller-deploy.
kubectl edit deploy –namespace kube-system tiller-deploy
插入一行 （serviceAccount: tiller） in the spec: template: spec section of the file:
…
spec:
  replicas: 1
  selector:
 matchLabels:
   app: helm
   name: tiller
  strategy:
 rollingUpdate:
   maxSurge: 1
   maxUnavailable: 1
 type: RollingUpdate
  template:
 metadata:
   creationTimestamp: null
   labels:
     app: helm
     name: tiller
 spec:
   serviceAccount: tiller
   containers:
    &lt;ul&gt;
      &lt;li&gt;env:
        &lt;ul&gt;
          &lt;li&gt;name: TILLER_NAMESPACE
value: kube-system
。。。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;文本修改配置&quot;&gt;文本修改配置&lt;/h3&gt;
&lt;h3 id=&quot;配置helm的service-account及其相关角色&quot;&gt;配置helm的Service account及其相关角色&lt;/h3&gt;
&lt;p&gt;[root@k8s-master helm]# vi helm-rbac.yml 
—
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    k8s-app: helm
  name: helm-admin
  namespace: kube-system&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: helm-admin
  labels:
    k8s-app: helm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kind: ServiceAccount
name: helm-admin
namespace: kube-system&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[root@k8s-master helm]# kubectl apply -f helm-rbac.yml&lt;/p&gt;

&lt;p&gt;注意，默认情况下只需要执行 helm init 就可以完成tiller部署，而且看上去很正常，但是无法执行 helm install 。因为helm需要访问k8s的API，而我们的集群启用了RBAC，要让helm正常工作，我们需要为其配置好相关权限。&lt;/p&gt;

&lt;h3 id=&quot;部署tiller并为其指定sa&quot;&gt;部署tiller并为其指定sa&lt;/h3&gt;
&lt;p&gt;[root@k8s-master helm]# helm init –service-account helm-admin&lt;/p&gt;

&lt;h3 id=&quot;如果你不是第一次执行&quot;&gt;如果你不是第一次执行&lt;/h3&gt;
&lt;p&gt;[root@k8s-master helm]# helm init –service-account helm-admin –upgrade&lt;/p&gt;

&lt;h3 id=&quot;安装检测及失败分析处理&quot;&gt;安装检测及失败分析处理&lt;/h3&gt;
&lt;p&gt;1.检测Tiller是否成功安装：
$kubectl get po -n kube-system&lt;/p&gt;

&lt;p&gt;成功状态：
NAME                                         READY     STATUS    RESTARTS   AGE
tiller-deploy-7dd5fbfd8f-hgpx6               1/1       Running   0          2m&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;失败分析处理
（1）镜像拉取失败&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;失败现状：&lt;/p&gt;

&lt;p&gt;$kubectl get po -n kube-system&lt;/p&gt;

&lt;p&gt;NAME                                         READY     STATUS    RESTARTS   AGE
tiller-deploy-7dd5fbfd8f-hgpx6               0/1  ImagePullBackOff   0      2m&lt;/p&gt;

&lt;p&gt;(2) 问题分析处理
helm init  在缺省配置下， Helm 会利用 “gcr.io/kubernetes-helm/tiller” 镜像在Kubernetes集群上安装配置 Tiller；并且利用 “https://kubernetes-charts.storage.googleapis.com” 作为缺省的 stable repository 的地址。由于在国内可能无法访问 “gcr.io”, “storage.googleapis.com” 等域名，阿里云容器服务为此提供了镜像站点。&lt;/p&gt;

&lt;p&gt;请执行如下命令利用阿里云的镜像来配置 Helm&lt;/p&gt;

&lt;p&gt;helm init –upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.9.1 –stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts&lt;/p&gt;

&lt;p&gt;（2）unable to do port forwarding: socat not found.
（1）失败现状
[root@k8s-master hello-svc]# helm version
Client: &amp;amp;version.Version{SemVer:”v2.8.1”, GitCommit:”6af75a8fd72e2aa18a2b278cfe5c7a1c5feca7f2”, GitTreeState:”clean”}
E0224 14:13:16.077226    7416 portforward.go:331] an error occurred forwarding 37271 -&amp;gt; 44134: error forwarding port 44134 to pod 76a7312e49220a229e443546a4b32d3e0406f09fd9b3646b3d30f6833e121375, uid : unable to do port forwarding: socat not found.
Error: cannot connect to Tiller
（2）问题分析处理
解决办法在node节点安装socat
yum install socat&lt;/p&gt;

&lt;p&gt;(3)版本不一致
(1)失败现状
Client: &amp;amp;version.Version{SemVer:”v2.9.1”, GitCommit:”20adb27c7c5868466912eebdf6664e7390ebe710”, GitTreeState:”clean”}
Server: &amp;amp;version.Version{SemVer:”v2.6.1”, GitCommit:”bbc1f71dc03afc5f00c6ac84b9308f8ecb4f39ac”, GitTreeState:”clean”}&lt;/p&gt;

&lt;p&gt;(2)问题分析处理
重新下载helm一致的版本包，和images的版本保持一致
或者更新更新tiller版本
helm init –upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.9.1&lt;/p&gt;

&lt;h3 id=&quot;chatt-repo&quot;&gt;chatt repo&lt;/h3&gt;
&lt;p&gt;chart repo是一个可用来存储index.yml与打包的chart文件的HTTP server。&lt;/p&gt;

&lt;p&gt;当要分享chart时，需要上传chart文件到chart仓库。任何一个能能够提供YAML与tar文件的HTTP server都可以当做chart仓库，比如Google Cloud Storage (GCS) bucket、Amazon S3 bucket、Github Pages或创建你自己的web服务器。官方chart仓库由Kubernetes Charts维护， Helm允许我们创建私有chart仓库。&lt;/p&gt;

&lt;p&gt;3.1 chart repo结构
查看目前的repo，helm repo list:&lt;/p&gt;

&lt;p&gt;NAME            URL
stable          https://kubernetes-charts.storage.googleapis.com
local           http://127.0.0.1:8879/charts
helm执行tiller命令后默认会配置一个名为local的本地repo。&lt;/p&gt;

&lt;p&gt;一个chart仓库由一个chart包与index.yaml文件组成，index.yaml记录了chart仓库中全部chart的索引，一个本地chart仓库的布局例子如下：&lt;/p&gt;

&lt;p&gt;~/.helm/
|– cache
| &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;-- archive
| |-- drupal-0.9.2.tgz
| 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;– mariadb-1.0.3.tgz
|– plugins
|– repository
| |– cache
| | |– fantastic-charts-index.yaml
| | |– local-index.yaml -&amp;gt; /home/ts1/.helm/repository/local/index.yaml
| | |– mariadb-1.0.3.tgz-index.yaml
| | |– memcached-1.2.1.tgz-index.yaml
| | |– mychart_xia-0.1.0.tgz-index.yaml
| | |– mysql-0.2.8.tgz-index.yaml
| | |– stable-index.yaml
| | |– test-0.1.0.tgz-index.yaml
| | &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;-- test-0.1.8.tgz-index.yaml
| |-- local
| | |-- index.yaml
| | |-- mychart-0.1.0.tgz
| | |-- mychart_xia-0.1.0.tgz
| | |-- mysql-0.2.8.tgz
| | |-- mysql-6.19.centos-29.tgz
| | |-- test-0.1.0.tgz
| | |-- test-0.1.8.tgz
| | 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;– test-0.1.9.tgz
| &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;-- repositories.yaml
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;– starters&lt;/p&gt;

&lt;p&gt;~/.helm/repository/local/index.yaml文件中记录了chart的诸如名称、url、version等一些metadata信息。&lt;/p&gt;

&lt;p&gt;3.2 启动repo服务
&amp;lt;1&amp;gt;创建repo目录：&lt;/p&gt;

&lt;p&gt;mkdir -p /dcos/appstore/local-repo&lt;/p&gt;

&lt;p&gt;备注： 此处我没用默认的local repo，而是创建一个新的文件夹并创建一个新的repo演示。&lt;/p&gt;

&lt;p&gt;&amp;lt;2&amp;gt;启动本地repo仓库服务:&lt;/p&gt;

&lt;p&gt;helm serve –address 0.0.0.0:8879 –repo-path /dcos/appstore/local-repo &amp;amp;&lt;/p&gt;

&lt;p&gt;&amp;lt;3&amp;gt;通过helm repo add命令添加本地repo：&lt;/p&gt;

&lt;p&gt;helm repo add local-repo http://10.142.21.21:8879
    “local-repo” has been added to your repositories&lt;/p&gt;

&lt;p&gt;&amp;lt;4&amp;gt;查看本地chart仓库是否添加成功：&lt;/p&gt;

&lt;p&gt;helm repo list:&lt;/p&gt;

&lt;p&gt;NAME            URL
stable          https://kubernetes-charts.storage.googleapis.com
local           http://127.0.0.1:8879/charts
local-repo      http://10.142.21.21:8879&lt;/p&gt;

&lt;p&gt;备注：helm serve 不指定任何参数的话会在默认的repo目录（/root/.helm/repository/local 
启动服务，根据该目录下的软件包（tgz）信息在该目录下创建index.html文件。
可以通过指定–repo-path参数实现在自定义的目录下启动服务，并在那个目录下创建index.html文件。&lt;/p&gt;

&lt;p&gt;3.3 向repo中增加软件包
上面步骤中，已经创建了一个本地的repo，接下来讲述如何在repo中增加一个可用来部署的软件包chart。chart须遵循 SemVer 2 规则填写正确的版本格式。各种chart包可以在github下载。&lt;/p&gt;

&lt;p&gt;&amp;lt;1&amp;gt;将chart文件夹移动到repo目录，并将chart打包：&lt;/p&gt;

&lt;p&gt;cp -r jenkins /dcos/appstore/local-repo/
cd /dcos/appstore/local-repo
helm package jenkins –save=false&lt;/p&gt;

&lt;p&gt;备注:&lt;/p&gt;

&lt;p&gt;helm package的作用是在当前目录下将软件打包为tgz，假如这个软件包中有requirement.yaml，则打包时还需要加上–dependency-update，用来update dependencies from “requirements.yaml” to dir “charts/” before packaging
–save=false的作用是不将tgz文件再拷贝一份到默认的local chart repo文件夹（/root/.helm/repository/local/）下，否则默认会将tgz拷贝一份到那，并检查那个目录下的index.html是否存在，不存在会报错。或者在3.2中最后把没用到的local repo删掉，就不用加–save=false了。&lt;/p&gt;

&lt;p&gt;&amp;lt;2&amp;gt;更新index.yaml文件 
通过helm repo index 命令将chart的metadata记录更新在index.yaml文件中:&lt;/p&gt;

&lt;p&gt;cd /dcos/appstore/local-repo
helm repo index –url=http://10.142.21.21:8879 .  &lt;br /&gt;
helm repo update&lt;/p&gt;

&lt;p&gt;备注： 
这句话的作用是:Read the current directory and generate an index file based on the charts found.&lt;/p&gt;

&lt;p&gt;&amp;lt;3&amp;gt;验证&lt;/p&gt;

&lt;p&gt;查找新上传的chart: 
helm search jenkins
NAME                    CHART VERSION   APP VERSION DESCRIPTION
local-repo/jenkins  0.16.3          2.107       Open source continuous integration server. It s…
stable/jenkins          0.16.3          2.107       Open source continuous integration server. It s…&lt;/p&gt;

&lt;p&gt;安装chart软件包（即release过程）：
helm install local-repo/jenkins&lt;/p&gt;

&lt;p&gt;备注：helm install会用到socat，需要在所有节点上安装socat&lt;/p&gt;

&lt;h3 id=&quot;导入chart&quot;&gt;导入chart&lt;/h3&gt;
&lt;p&gt;Helm 支持四种安装方法：&lt;/p&gt;

&lt;p&gt;安装仓库中的 chart，例如：helm install stable/nginx&lt;/p&gt;

&lt;p&gt;通过 tar 包安装，例如：helm install ./nginx-1.2.3.tgz&lt;/p&gt;

&lt;p&gt;通过 chart 本地目录安装，例如：helm install ./nginx&lt;/p&gt;

&lt;p&gt;通过 URL 安装，例如：helm install https://example.com/charts/nginx-1.2.3.tgz&lt;/p&gt;

&lt;h4 id=&quot;chart&quot;&gt;Chart&lt;/h4&gt;
&lt;p&gt;Helm管理的kubernetes资源包称之为Chart，Chart是一个结构相对固定的文件目录。一个单独的Chart可以用于部署一下简单的Kubernetes资源，如：memcached，又或者更复杂的应用，如完整的Web应用：HTTP servers, databases, caches等等。&lt;/p&gt;

&lt;p&gt;3.1、Chart的结构
[root@k8s-master mychart]# tree mychart/
mychart                              # Chart的名字，也就是目录的名字
├── charts                           # Chart所依赖的子Chart
│   ├── jenkins-0.14.0.tgz           # 被“mychart”依赖的其中一个subChart
│   ├── mysubchart                   # 被“mychart”依赖的另一个subChart
│   │   ├── charts                 &lt;br /&gt;
│   │   ├── Chart.yaml
│   │   ├── templates
│   │   │   └── configmap.yaml
│   │   └── values.yaml
│   └── redis-1.1.17.tgz           &lt;br /&gt;
├── Chart.yaml                       # 记录关于该Chart的描述信息：比如名称、版本等等
├── config1.toml                     # 其他文件：可以是任何文件
├── config2.toml                     # 其他文件：可以是任何文件
├── requirements.yaml                # 记录该Chart的依赖，类似pom.xml
├── templates                        # 存放模版文件，模板也就是将k8s的yml文件参数化，最终还是会被helm处理成k8s的正常yml文件，然后用来部署对应的资源
│   ├── configmap.yaml               # 一个ConfigMap资源模版
│   ├── &lt;em&gt;helpers.tpl                 # “&lt;/em&gt;“开头的文件不会本部署到k8s上，可以用于定于通用信息，在其他地方应用，如loables
│   └── NOTES.txt                    # 在执行helm instll安装此Chart之后会被输出到屏幕的一些自定义信息
└── values.yaml                      # 参数定义文件，这里定义的参数最终会应用到模版中&lt;/p&gt;

&lt;p&gt;Chart可以是目录，也可以是tgz格式的压缩包。&lt;/p&gt;

&lt;p&gt;charts目录和requirements.yaml文件到区别就和lib和pom.xml的区别类似，一个用于存放，一个用于描述&lt;/p&gt;

&lt;p&gt;###
3.1.1、创建一个Chart
[root@k8s-master charts]# pwd
/root/charts&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# helm create mychart-2&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# ll
drwxr-xr-x. 4 root root  93 3月  12 10:48 mychart-2&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# tree mychart-2
mychart-2
├── charts
├── Chart.yaml
├── templates
│   ├── deployment.yaml
│   ├── _helpers.tpl
│   ├── ingress.yaml
│   ├── NOTES.txt
│   └── service.yaml
└── values.yaml&lt;/p&gt;

&lt;p&gt;2 directories, 7 files&lt;/p&gt;

&lt;p&gt;或者获取chart
获取版本为0.2.8的mysql并解压缩包：&lt;/p&gt;

&lt;p&gt;$ helm fetch stable/mysql –version 0.2.8 –untar
$ ls mysql/
 Chart.yaml README.md templates values.yaml&lt;/p&gt;

&lt;p&gt;利用helm lint命令检查下载的chart是否存在问题：
$ helm lint mysql
 ==&amp;gt; Linting mysql
 Lint OK
1 chart(s) linted, no failures&lt;/p&gt;

&lt;p&gt;盖chart中的默认值，通过指定配置文件方式：&lt;/p&gt;

&lt;p&gt;helm install -f myvalues.yaml ./redis
或者通过–set key=value形式：&lt;/p&gt;

&lt;p&gt;$ helm install –set name=prod ./redis&lt;/p&gt;

&lt;p&gt;安装release名称为mysql例子如下，请注意NOTES中对Mysql的使用说明：&lt;/p&gt;

&lt;p&gt;$ helm install -n mysql -f mysql/values.yaml –set resources.requests.memory=512Mi mysql
NAME: mysql
LAST DEPLOYED: Thu Sep 14 05:48:31 2017
NAMESPACE: default
STATUS: DEPLOYED&lt;/p&gt;

&lt;p&gt;通过helm status查看release状态：&lt;/p&gt;

&lt;p&gt;$ helm status mysql
 LAST DEPLOYED: Tue Sep 12 07:31:49 2017
 NAMESPACE: default
 STATUS: DEPLOYED
或通过helm list -a查看全部的release，tag “-a”是查看全部的release，包括已部署、部署失败、正在删除、已删除release等。&lt;/p&gt;

&lt;p&gt;$ helm list -a
$ helm list -a | grep mysqlmysql           1       Tue Sep 12 07:31:49 2017 DEPLOYED mysql-0.2.8         default&lt;/p&gt;

&lt;p&gt;更新release
Helm使用helm upgrade更新已安装的release：&lt;/p&gt;

&lt;p&gt;$ helm upgrade mysql -f mysql/values.yaml –set resources.requests.memory=1024Mi mysql
查看指定release的历史部署版本信息：&lt;/p&gt;

&lt;p&gt;$ helm hist  mysql
REVISION    UPDATED                        STATUS           CHART          DESCRIPTION
1           Tue Sep 12 07:31:49 2017       SUPERSEDED       mysql-0.2.8    Install complete
2           Tue Sep 12 07:44:00 2017       DEPLOYED         mysql-0.2.8    Upgrade complete
查看指定release的历史版本部署时部分配置信息，以resources.requests.memory为例，符合查看部署符合预期：即第一次部署resources.requests.memory设置为512Mi，第二次的升级resources.requests.memory设置为1024Mi：&lt;/p&gt;

&lt;p&gt;$ helm get –revision 1 mysql
 resources:
 requests:
 cpu: 100m
 memory: 512Mi&lt;/p&gt;

&lt;p&gt;$ helm get –revision 2 mysql
resources:
 requests:
 cpu: 100m
 memory: 1024Mi&lt;/p&gt;

&lt;p&gt;版本回滚
回滚到第一次的版本：&lt;/p&gt;

&lt;p&gt;helm rollback –debug mysql 1
[debug] Created tunnel using local port: ‘60303’
[debug] SERVER: “localhost:60303”
Rollback was a success! Happy Helming!
查看mysql release的版本信息，当前已经回滚到REVISION为1的版本：&lt;/p&gt;

&lt;p&gt;$ helm hist mysql
REVISION           UPDATED                    STATUS        CHART          DESCRIPTION
1                  Tue Sep 12 07:31:49 2017   SUPERSEDED    mysql-0.2.8    Install complete
2                  Tue Sep 12 07:44:00 2017   SUPERSEDED    mysql-0.2.8    Upgrade complete
3                  Tue Sep 12 08:50:48 2017   DEPLOYED      mysql-0.2.8    Rollback to 1
删除chart
$ helm delete mysql
 release “mysql” deleted
确认chart是否删除：&lt;/p&gt;

&lt;p&gt;$ helm ls -a mysql
NAME     REVISION      UPDATED                     STATUS      CHART           NAMESPACE
mysql    3             Tue Sep 12 08:50:48 2017    DELETED     mysql-0.2.8     default
即使删除的chart，其发布的历史信息还是继续被保存。&lt;/p&gt;

&lt;p&gt;$ helm hist mysql
REVISION      UPDATED                     STATUS         CHART          DESCRIPTION
1             Tue Sep 12 07:31:49 2017    SUPERSEDED     mysql-0.2.8    Install complete
2             Tue Sep 12 07:44:00 2017    SUPERSEDED     mysql-0.2.8    Upgrade complete
3             Tue Sep 12 08:50:48 2017    DELETED        mysql-0.2.8    Deletion complete
可以恢复一个已经删除的release：&lt;/p&gt;

&lt;p&gt;$ helm rollback –debug mysql 2
[debug] Created tunnel using local port: ‘37413’
[debug] SERVER: “localhost:37413”
Rollback was a success! Happy Helming!
如果希望彻底删除一个release，可以用如下命令：&lt;/p&gt;

&lt;p&gt;$ helm delete –purge mysql
 release “mysql” deleted
再次查看刚被删除的mysql release，提示已经无法找到，符合预期：&lt;/p&gt;

&lt;p&gt;$ helm hist mysql
 Error: release: “mysql” not found&lt;/p&gt;

&lt;h3 id=&quot;为了后面的实验我们先删除helm默认生成的文件&quot;&gt;为了后面的实验，我们先删除helm默认生成的文件&lt;/h3&gt;
&lt;p&gt;[root@k8s-master charts]# rm -rf mychart-2/templates/*&lt;/p&gt;

&lt;p&gt;helm会帮我们创建一下必要的模版文件，简单的Chart直接修改这些文件即可&lt;/p&gt;

&lt;p&gt;3.1.2、文件：Chart.yaml
[root@k8s-master charts]# vi mychart-2/Chart.yaml 
apiVersion: v1
appVersion: “1.0”
description: A Helm chart for Kubernetes
name: mychart-2
version: 0.1.0&lt;/p&gt;

&lt;p&gt;apiVersion：官网文档上没有，helm create创建的的模版中有，指k8s API的版本
appVersion：当前Chart包含的应用的版本，比如redis、apache等
description：当前Chart的描述信息
name：当前Chart的名称
version：当前Chart的版本，版本规范，打包后的文件名：name-version.tgz，如：nginx-1.2.3.tgz&lt;/p&gt;

&lt;p&gt;name: [必须] Chart的名称
version: [必须] Chart的版本号，版本号必须符合 SemVer 2：http://semver.org/
description: [可选] Chart的简要描述
keywords:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;[可选] 关键字列表
home: [可选] 项目地址
sources:&lt;/li&gt;
  &lt;li&gt;[可选] 当前Chart的下载地址列表
maintainers: # [可选]&lt;/li&gt;
  &lt;li&gt;name: [必须] 名字
email: [可选] 邮箱
engine: gotpl # [可选] 模版引擎，默认值是gotpl
icon: [可选] 一个SVG或PNG格式的图片地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.1.3、文件：values.yaml
此文件主要用来存放Chart的默认值，这些值会被应用到模版中，替换掉模版中的变量，生成最终k8s的yaml部署文件，例如：&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# vi mychart/values.yaml
favorite:
  drink: coffee
  food: pizza&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# vi mychart/templates/configmap.yaml 
apiVersion: v1
kind: ConfigMap
metadata:
  name: -configmap
data:
  myvalue: “Hello World”
  drink: 
  food:&lt;/p&gt;

&lt;p&gt;在这个例子中，我们有一个configmap.yaml模版，模版中点了一个ConfigMap，模版中包含了很多  ，这些  中以.Values开头的会被替换成values.yaml中的值，.Release开头的会被替换成release相关的变量值，Release是内置变量中的一员。quote是一个function，当然还有很多其他的function。&lt;/p&gt;

&lt;p&gt;这里为什么说默认值呢，因为在执行 helm install 时，可以通过 helm install –set tags.front-end=true –set subchart2.enabled=false 这种方式来改变实际的值。&lt;/p&gt;

&lt;p&gt;3.1.4、文件：requirements.yaml
关于template的详细内容，将在下文阐述。&lt;/p&gt;

&lt;p&gt;这个文件需要手动创建，requirements.yaml文件用来定义Chart的依赖，直接将这些依赖放到chart目录下也是可以的。使用文件来管理是来会更加便利。简单文件的格式如下：&lt;/p&gt;

&lt;p&gt;dependencies:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;name: redis
version: 1.1.17
repository: https://kubernetes-charts.storage.googleapis.com&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件内容表明当前Chart依赖redis-1.1.17这个Chart，这个Chart的仓库地址是https://kubernetes-charts.storage.googleapis.com，这个地址必须已经添加到你的helm中，添加命令：helm repo add ，查看命令：helm repo list 。&lt;/p&gt;

&lt;p&gt;然后我们执行 helm dependency update chartName 命令helm就会帮我们下载requirements.yaml文件中定义的其他Chart，这些Chart会存放在charts目录中。&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# helm dependency update mychart-2/
Hang tight while we grab the latest from your chart repositories…
…Successfully got an update from the “stable” chart repository
Update Complete. ⎈Happy Helming!⎈
Saving 1 charts
Downloading redis from repo https://kubernetes-charts.storage.googleapis.com
Deleting outdated charts&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# ll mychart-2/charts/
总用量 8
-rw-r–r–. 1 root root 6189 3月  12 10:54 redis-1.1.17.tgz
命令简写：helm dep up mychart-2/&lt;/p&gt;

&lt;p&gt;下面是一个复杂一点的例子：&lt;/p&gt;

&lt;p&gt;dependencies:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;name: redis
version: 1.1.17
repository: https://kubernetes-charts.storage.googleapis.com
condition: redis.enabled
tags:
    &lt;ul&gt;
      &lt;li&gt;redis&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;name: jenkins
version: 0.14.0
repository: https://kubernetes-charts.storage.googleapis.com
condition: jenkins.enabled
tags:
    &lt;ul&gt;
      &lt;li&gt;jenkins&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;name: redis
version: 1.1.17
repository: https://kubernetes-charts.storage.googleapis.com
alias: newname
tags:
    &lt;ul&gt;
      &lt;li&gt;redis&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这个例子中，涉及到alias、condition、tags三个关键字，我们配合下面的values.yaml文件一项一项来解释，values.yaml文件内容：&lt;/p&gt;

&lt;p&gt;redis:
  enabled: false&lt;/p&gt;

&lt;p&gt;jenkins:
  enabled: false&lt;/p&gt;

&lt;p&gt;tags:
  redis: false
  jenkins: true&lt;/p&gt;

&lt;p&gt;alias：给依赖的Chart定义别名，官网上说：别名会在下载之后，以新名称存放在charts目录下，但是实时上并非如此。在我的实验过程中，上面的例子会下载三个Chart：redis、jenkins和redis，也就是redis下载了两次，但是在charts目录下只有redis和jenkins两个文件，没有newname。我在想alias目前可能只是记录在文件中，最后一个redis依然叫redis，而且将第一个redis覆盖了，所以只有两个文件。也可能是我的实验姿势不对。
condition：boolean值，用来决定当前依赖是否启用，如果condition后面的值不存在，比如redis.enabled或者jenkins.enabled未定义，则忽略condition。condition可定义多个值，用 “,” 分隔。如果第一个值存在，则忽略后面的值。
tags：boolean值，与condition类似，但是condition的优先级更高，如果同时定义了condition和tags，tags将被忽略。在不考虑condition时，tags中的任何一个值被定义为true，则启用该依赖&lt;/p&gt;

&lt;p&gt;3.1.5、目录：charts
目录charts用来存放当前Chart依赖的其他Chart，这些被依赖的Chart可以是上文requirements.yaml文件中描述的，也可以直接在charts目录下创建新的charts&lt;/p&gt;

&lt;p&gt;[root@k8s-master charts]# cd mychart-2/charts/
[root@k8s-master charts]# pwd
/root/charts/mychart-2/charts
[root@k8s-master charts]# helm create mysubchart-1
Creating mysubchart-1
[root@k8s-master charts]# helm create mysubchart-2
Creating mysubchart-2
[root@k8s-master charts]# ll
drwxr-xr-x. 4 root root 93 3月  12 12:10 mysubchart-1
drwxr-xr-x. 4 root root 93 3月  12 12:10 mysubchart-2&lt;/p&gt;

&lt;p&gt;每个subChart都是一个结构完整的Chart，可以是目录，也可以是tgz文件，tgz文件可以用 tar -zxvf 命令解压
此时若部署mychart-2，也会连同mysubchart-1和mysubchart-2一同部署到k8s上&lt;/p&gt;

&lt;h3 id=&quot;helm-命令行&quot;&gt;helm 命令行&lt;/h3&gt;

&lt;h3 id=&quot;添加仓库&quot;&gt;添加仓库&lt;/h3&gt;
&lt;p&gt;$helm repo add fabric8 https://fabric8.io/helm&lt;/p&gt;

&lt;h3 id=&quot;查看仓库&quot;&gt;查看仓库&lt;/h3&gt;
&lt;p&gt;$helm repo list&lt;/p&gt;

&lt;h3 id=&quot;重制仓库&quot;&gt;重制仓库&lt;/h3&gt;
&lt;p&gt;$helm repo reset&lt;/p&gt;

&lt;p&gt;搜索fabric8提供的工具&lt;/p&gt;
&lt;h3 id=&quot;搜索charts&quot;&gt;搜索charts&lt;/h3&gt;
&lt;p&gt;$helm search fabric8&lt;/p&gt;

&lt;h4 id=&quot;部署artifactory&quot;&gt;部署artifactory&lt;/h4&gt;
&lt;p&gt;准备PV
阿里云上的Kebernetes集群目前不支持StorageClass，PV需要提前建好
Artifactory Instance一共需要三个PV，分别供数据库/Artifactory/Nginx使用，我的PV定义文件如下：
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv004
spec:
  capacity:
    storage: 1000Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: /opt/nfs/pv004
    server: 192.168.252.83&lt;/p&gt;

&lt;p&gt;Helm安装Artifactory Instance
使用helm安装非常方便，执行如下的命令等10分钟左右即可
helm install –name artifactory stable/artifactory&lt;/p&gt;

&lt;p&gt;###提示
helm 跟kubectl 一样，从.kube/config 读取配置证书跟k8s通讯，&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Aug 2018 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/kubenets-helm/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2018/08/07/kubenets-helm/</guid>
        
        <category>kubentes</category>
        
        <category>helm</category>
        
        
        <category>开发工具</category>
        
      </item>
    
      <item>
        <title>AI deep learn &amp; tensorflow opencv</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;因在数博会上对GOOGLE推出的Tensorflow颇感到兴趣，又从朋友听到深度学习及应用前景非常广。打算深度学习进行了解并对过程进行笔记。 主要使用tensorflow结合opencv对视频图像进行深度学习，对物品进行分析学习。例如识别车辆品牌及型号，物体快速识别。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;深度学习&quot;&gt;深度学习&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;深度学习的概念源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。深度学习是机器学习中一种基于对数据进行表征学习的方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;开发套件准备&quot;&gt;开发套件准备&lt;/h4&gt;

&lt;h5 id=&quot;开发环境工具&quot;&gt;开发环境工具&lt;/h5&gt;
&lt;p&gt;anaconda
指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。
&lt;a href=&quot;https://www.anaconda.org/&quot;&gt;官网&lt;/a&gt; 
&lt;a href=&quot;https://www.anaconda.com/download/#windows&quot;&gt;下载 windows&lt;/a&gt; 
&lt;a href=&quot;https://www.anaconda.com/download/#macos&quot;&gt;下载 macos&lt;/a&gt; 
&lt;a href=&quot;https://www.anaconda.com/download/#linux&quot;&gt;下载 linux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;官方提供了通过Graphical 和Command Line 两种方式，本文选择通过Graphical安装.
因本人MAC系统，选择下载最新基于Mac OS系统的Python 3.6进行安装。&lt;/p&gt;

&lt;h5 id=&quot;深度学习工具&quot;&gt;深度学习工具&lt;/h5&gt;
&lt;p&gt;tensorflow
是谷歌基于DistBelief进行研发的第二代人工智能学习系统，其命名来源于本身的运行原理。Tensor（张量）意味着N维数组，Flow（流）意味着基于数据流图的计算，TensorFlow为张量从流图的一端流动到另一端计算过程。TensorFlow是将复杂的数据结构传输至人工智能神经网中进行分析和处理过程的系统。TensorFlow可被用于语音识别或图像识别等多项机器学习和深度学习领域。
&lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;官网&lt;/a&gt;
&lt;a href=&quot;http://www.tensorfly.cn/&quot;&gt;中文社区&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;视频分析工具&quot;&gt;视频分析工具&lt;/h5&gt;
&lt;p&gt;opencv
是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。
&lt;a href=&quot;https://www.opencv.org/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;语言开发工具&quot;&gt;语言开发工具&lt;/h5&gt;
&lt;p&gt;vscode
Microsoft Visual Studio（简称VS）是美国微软公司的开发工具包系列产品。VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等。所写的目标代码适用于微软支持的所有平台，包括Microsoft Windows、Windows Mobile、Windows CE、.NET Framework、.NET Compact Framework和Microsoft Silverlight 及Windows Phone。
&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;开发语言&quot;&gt;开发语言&lt;/h5&gt;
&lt;p&gt;python
是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议。Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。
&lt;a href=&quot;https://www.python.org/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;环境安装&quot;&gt;环境安装&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;安装anaconda,选择下载安装包，直接安装完成。没有特殊选择项。安装anaconda主要目的是适应多版本python环境搭建及可进行包管理，后续大多数包都可在该系统下进行安装。创建现有环境，
&lt;img src=&quot;/img/in-post/original/2018-05-30-ai-deep-learn-2.png&quot; alt=&quot;image01&quot; /&gt;
创建环境分为命令行和图形创建：
(1). 命令行 创建开发环境命名为tensorflow的环境，适用3.6版本python的&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda create &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; tensorflow &lt;span class=&quot;nt&quot;&gt;-python&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.6
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;activate tensorflow&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;安装tensorflow。分为两种安装方式，
一种选择anaconda包管理方式进行下载。选择对应开发环境，选择all中，搜索tensorflow.
&lt;img src=&quot;/img/in-post/original/2018-05-30-ai-deep-learn-1.png&quot; alt=&quot;image01&quot; /&gt;
另一种功能适用pip进行下载。&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pip &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--ignore-installed&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--upgrade&lt;/span&gt; https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.6.0-py3-none-any.whl&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;安装opencv。安装方法类似。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;开发调试&quot;&gt;开发调试&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装vscode。可以选择从官网下载，也可以从conda中按照默认提供下载。
&lt;img src=&quot;/img/in-post/original/2018-05-30-ai-deep-learn-3.png&quot; alt=&quot;image03&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载vscode插件
安装python插件
&lt;img src=&quot;/img/in-post/original/2018-05-30-ai-deep-learn-4.png&quot; alt=&quot;image04&quot; /&gt;
配置python路径
&lt;img src=&quot;/img/in-post/original/2018-05-30-ai-deep-learn-5.png&quot; alt=&quot;image05&quot; /&gt;
如果通过官网下载vscode，还另需要安装conda插件
&lt;img src=&quot;/img/in-post/original/2018-05-30-ai-deep-learn-6.png&quot; alt=&quot;image06&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;测试程序&quot;&gt;测试程序&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;hello word&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过tensorflow 打印 hello word 以及输出opencv 输出版本。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;cv2&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__version__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'hello word!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
</description>
        <pubDate>Tue, 29 May 2018 22:00:00 +0800</pubDate>
        <link>https://minicool.github.io//ai/2018/05/29/AI-deep-learn/</link>
        <guid isPermaLink="true">https://minicool.github.io//ai/2018/05/29/AI-deep-learn/</guid>
        
        <category>deeplearning</category>
        
        <category>tensorflow</category>
        
        <category>opencv</category>
        
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>block chain &amp; trust issues</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;提到区块链，除了数字货币这个话题外，另一个话题常被人提到的是解决了陌生人信任问题。在对区块链这段时间的研究及理解中，个人觉得区块链能解决陌生人信任问题的能力明显的夸大了。退一步将，至少可以确定它能解决额问题是有限的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;区块链&quot;&gt;区块链&lt;/h4&gt;
&lt;p&gt;在本质上来说，区块链主要由共识协议，加密算法，数据结构等组成。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;共识协议：POW,POS,DPOS,PBFT等。（很多人甚至白皮书把共识协议叫做共识算法，我认为是不妥的。算法是解决特定问题数学计算的流程方式，协议是多方认可实行的操作方式。而共识更偏向协议这种解释。当然这只是我本人的理解，并不对这个学术名称进行过多解析）&lt;/li&gt;
  &lt;li&gt;加密算法：摘要：RIPEMD、SHA256 不对称加密向：ECC(椭圆曲线)算法等&lt;/li&gt;
  &lt;li&gt;数据结构：Merkle树，数据链表，块链结构等
本次主要讨论区块链的共识协议。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;共识协议&quot;&gt;共识协议&lt;/h4&gt;
&lt;p&gt;共识协议中主要的几种协议：（本身优缺点不做讨论）&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;POW (Proof of Work &amp;amp; 工作量证明): 即干的越多，收的越多。
依赖机器进行数学运算来获取记账权，资源消耗相比其他共识机制高、可监管性弱，同时每次达成共识需要全网共同参与运算，性能效率比较低，容错性方面允许全网50%节点出错。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POS（Proof of Stake &amp;amp; 权益证明）：即持有越多，获得越多。
主要是节点记账权的获得难度与节点持有的权益成反比，相对于PoW，一定程度减少了数学运算带来的资源消耗，性能也得到了相应的提升，但依然是基于哈希运算竞争获取记账权的方式，可监管性弱。该共识机制容错性和PoW相同。它是Pow的一种升级共识机制，根据每个节点所占代币的比例和时间，等比例的降低挖矿难度，从而加快找随机数的速度。总体来说获得了权重属性的POW协议。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DPOS（Delegated Proof of Stake，委任权益证明）：谁给我带来利益最大化，我就选谁
与PoS的主要区别在于节点选举若干代理人，由代理人验证和记账。其合规监管、性能、资源消耗和容错性与PoS相似。类似于董事会投票，持币者投出一定数量的节点，代理他们进行验证和记账。原理类似议会制度或人民代表大会制度。弱中心化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PBFT （Practical Byzantine Fault Tolerance，实用拜占庭容错）：我选你当老大，但是你每次干啥都要我审核
一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。前提需要提供了(n-1)/3的容错性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;信任和认可&quot;&gt;信任和认可&lt;/h4&gt;
&lt;p&gt;大家常常把这两种理解混在一起。本人所理解的更能准确描述。
认可：是常对某件事件，某个物件的认定。即对该事物表示认同不反对。狭义范围属于认定。
信任：是指在某人或某组织，可进行一步来说就是具有法定人的信任，授予其在范围内行驶权力的行为。狭义范围属于授权。&lt;/p&gt;

&lt;p&gt;以POW共识为例子：所有工作量的证明都是由算力对套用计算来获得随机数，以实现大家对该行为的认可。它自身并未有信任元素。
POS作为拥有权重属性的加强版POW协议，也和POW类似。
DPOS在认可上进行突破，形成了通过利益最大化来选择代理人。建立了弱信任元素。通过利益最大化来衡量。
PBFT表面上形成信任元素，但其本质还是认可行为，主要对选举出的领导的每次认可询问进行评定。&lt;/p&gt;

&lt;h4 id=&quot;数据上链风险及悖论&quot;&gt;数据上链风险及悖论&lt;/h4&gt;
&lt;p&gt;区块链不单单是数字货币这一个方向，如其他传统信息应用方向。涉及到链外数据进入链内方式。即数据上链方法。
而如何确定数据上链的安全性，即如何保证抄写员在本子上写的东西是真的，不存在私心进行修改的问题。
其实上述归纳来说，本质问题就是信任机制及风险。这种风险一般通过强信任模式和惩罚机制来制约。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;强信任模式，例如以太坊上的Oracle合约仲裁方。类似于现实生活中的银行，政府等。自身具有强信用背书。但这种存在方式又违背了陌生人信任模式。形成了弱中心化的行为。涉及外部合约等。&lt;/li&gt;
  &lt;li&gt;惩罚机制，如信任链中的全信任链崩塌，类似CA认证链。或者DPOS中无法获取委托高权益，将被委托人直接除名。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而上述制约模式都与区块链存在或多或少的悖论。
强信任模式，带了中心化的仲裁模式。惩罚机制，只是形成约束，并未能有效阻止发生。&lt;/p&gt;

&lt;h4 id=&quot;信任机制风险&quot;&gt;信任机制风险&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;认可替代信任。即POW模式，获得随机数即被认可。无需其余节点信任。优点：去信任，随时进行认可确定。缺点：POW存在的所有问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;强信用模式，类似CA证书链。根节点为强信用节点，为子节点进行链式分发，并为子节点实现链式隐形信任担保。作为强信用模式，必然形成中心化。优点：自身权威性。缺点：违背了区块链去中心化，需要强力信用进行背书。例如：以太坊上的ORACLE提供商，如何确定其仲裁的合法性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;信任的发展机制&quot;&gt;信任的发展机制&lt;/h4&gt;
&lt;p&gt;在人类历史角度中看信任的发展，都从陌生到认定，再从认定到信任，信任到权威的发展方式。而这一系列的信任转化，就形成了现有信用链。强信用模式下，往往&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Mar 2018 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E9%97%AE%E9%A2%98%E6%8E%A2%E8%AE%A8/2018/03/30/blockchain-bug/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E9%97%AE%E9%A2%98%E6%8E%A2%E8%AE%A8/2018/03/30/blockchain-bug/</guid>
        
        <category>block-chain</category>
        
        
        <category>问题探讨</category>
        
      </item>
    
  </channel>
</rss>
