<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MiniCool World</title>
    <description>年迈的工程师</description>
    <link>https://minicool.github.io//</link>
    <atom:link href="https://minicool.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 06 Mar 2018 00:05:16 +0800</pubDate>
    <lastBuildDate>Tue, 06 Mar 2018 00:05:16 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>RSA encryption algorithm</title>
        <description>&lt;h3 id=&quot;rsa-简史&quot;&gt;RSA 简史&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;RSA加密算法基于整数分解原理形成。 通过对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;rsa-原理&quot;&gt;RSA 原理&lt;/h3&gt;

&lt;h3 id=&quot;rsa-缺点&quot;&gt;RSA 缺点&lt;/h3&gt;

&lt;h3 id=&quot;rsa-应用&quot;&gt;RSA 应用&lt;/h3&gt;
&lt;h4 id=&quot;加密解密&quot;&gt;加密，解密&lt;/h4&gt;

&lt;h4 id=&quot;签名验证&quot;&gt;签名，验证&lt;/h4&gt;
</description>
        <pubDate>Thu, 23 Apr 2015 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E7%AC%94%E8%AE%B0/2015/04/23/RSA-encryption-algorithm/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E7%AC%94%E8%AE%B0/2015/04/23/RSA-encryption-algorithm/</guid>
        
        <category>密码学</category>
        
        <category>算法</category>
        
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>Encryption algorithm summary</title>
        <description>&lt;h3 id=&quot;加密算法&quot;&gt;加密算法&lt;/h3&gt;
&lt;p&gt;根据密钥类型不同可以将现代密码技术分为两类：对称加密算法（私钥密码体系）和非对称加密算法（公钥密码体系）。
对称加密&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Mar 2015 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E7%AC%94%E8%AE%B0/2015/03/26/Encryption-algorithm-summary/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E7%AC%94%E8%AE%B0/2015/03/26/Encryption-algorithm-summary/</guid>
        
        <category>密码学</category>
        
        <category>算法</category>
        
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>SQL concurrency controlr</title>
        <description>&lt;h3 id=&quot;乐观锁&quot;&gt;乐观锁&lt;/h3&gt;

&lt;p&gt;乐观锁做为关系性数据库中的一种并发控制方法。它假设数据库运行提交事务处理时候，并不会相互影响。各事务能够在不产生锁的情况下进行处理各自数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。&lt;/p&gt;

&lt;h4 id=&quot;应用&quot;&gt;应用&lt;/h4&gt;
&lt;p&gt;乐观并发控制多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。&lt;/p&gt;

&lt;h4 id=&quot;控制阶段&quot;&gt;控制阶段&lt;/h4&gt;
&lt;p&gt;乐观并发控制的事务包括以下阶段：
读取：事务将数据读入缓存，这时系统会给事务分派一个时间戳。
校验：事务执行完毕后，进行提交。这时同步校验所有事务，如果事务所读取的数据在读取之后又被其他事务修改，则产生冲突，事务被中断回滚。
写入：通过校验阶段后，将更新的数据写入数据库。&lt;/p&gt;

&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。&lt;/p&gt;

&lt;h3 id=&quot;悲观锁&quot;&gt;悲观锁&lt;/h3&gt;
&lt;p&gt;它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。&lt;/p&gt;

&lt;h4 id=&quot;应用-1&quot;&gt;应用&lt;/h4&gt;
&lt;p&gt;悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。&lt;/p&gt;

&lt;h4 id=&quot;控制阶段-1&quot;&gt;控制阶段&lt;/h4&gt;

&lt;h4 id=&quot;优缺点-1&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;悲观并发控制实际上是“先取锁再访问”的保守策略[1]，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。&lt;/p&gt;

&lt;h4 id=&quot;acid&quot;&gt;ACID&lt;/h4&gt;
&lt;p&gt;ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。&lt;/p&gt;

&lt;p&gt;在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。ACID的概念在ISO/IEC 10026-1:1992文件的第四段内有所说明。&lt;/p&gt;

&lt;p&gt;原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Jul 2014 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E7%AC%94%E8%AE%B0/2014/07/28/SQL-concurrency-control/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E7%AC%94%E8%AE%B0/2014/07/28/SQL-concurrency-control/</guid>
        
        <category>SQL</category>
        
        <category>基础知识</category>
        
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>deadlock livelock starvation</title>
        <description>&lt;h3 id=&quot;死锁简述&quot;&gt;死锁简述&lt;/h3&gt;

&lt;h4 id=&quot;死锁发生的条件&quot;&gt;死锁发生的条件&lt;/h4&gt;

&lt;h4 id=&quot;死锁例子&quot;&gt;死锁例子&lt;/h4&gt;

&lt;h3 id=&quot;活锁简述&quot;&gt;活锁简述&lt;/h3&gt;

&lt;h3 id=&quot;饿死简述&quot;&gt;饿死简述&lt;/h3&gt;
</description>
        <pubDate>Thu, 13 Jun 2013 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E7%AC%94%E8%AE%B0/2013/06/13/deadlock-livelock-starvation/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E7%AC%94%E8%AE%B0/2013/06/13/deadlock-livelock-starvation/</guid>
        
        <category>基础知识</category>
        
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>SQL execution order</title>
        <description>&lt;h3 id=&quot;1逻辑查询处理阶段简介&quot;&gt;1.逻辑查询处理阶段简介&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;(8)SELECT (9)DISTINCT  (11)&amp;lt;Top Num&amp;gt; &amp;lt;select list&amp;gt;&lt;/p&gt;

  &lt;p&gt;(1)FROM [left_table]&lt;/p&gt;

  &lt;p&gt;(3)&lt;join_type&gt; JOIN &lt;right_table&gt;&lt;/right_table&gt;&lt;/join_type&gt;&lt;/p&gt;

  &lt;p&gt;(2)ON &lt;join_condition&gt;&lt;/join_condition&gt;&lt;/p&gt;

  &lt;p&gt;(4)WHERE &lt;where_condition&gt;&lt;/where_condition&gt;&lt;/p&gt;

  &lt;p&gt;(5)GROUP BY &lt;group_by_list&gt;&lt;/group_by_list&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;(6)WITH &amp;lt;CUBE &lt;/td&gt;
        &lt;td&gt; RollUP&amp;gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

  &lt;p&gt;(7)HAVING &lt;having_condition&gt;&lt;/having_condition&gt;&lt;/p&gt;

  &lt;p&gt;(10)ORDER BY &lt;order_by_list&gt;&lt;/order_by_list&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;FROM：对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1&lt;/li&gt;
  &lt;li&gt;ON：对VT1应用ON筛选器。只有那些使&lt;join_condition&gt;为真的行才被插入VT2。&lt;/join_condition&gt;&lt;/li&gt;
  &lt;li&gt;OUTER(JOIN)：如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。&lt;/li&gt;
  &lt;li&gt;WHERE：对VT3应用WHERE筛选器。只有使&lt;where_condition&gt;为true的行才被插入VT4.&lt;/where_condition&gt;&lt;/li&gt;
  &lt;li&gt;GROUP BY：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;CUBE&lt;/td&gt;
          &lt;td&gt;ROLLUP：把超组(Suppergroups)插入VT5,生成VT6.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;HAVING：对VT6应用HAVING筛选器。只有使&lt;having_condition&gt;为true的组才会被插入VT7.&lt;/having_condition&gt;&lt;/li&gt;
  &lt;li&gt;SELECT：处理SELECT列表，产生VT8.&lt;/li&gt;
  &lt;li&gt;DISTINCT：将重复的行从VT8中移除，产生VT9.&lt;/li&gt;
  &lt;li&gt;ORDER BY：将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).&lt;/li&gt;
  &lt;li&gt;TOP：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 27 May 2013 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E7%AC%94%E8%AE%B0/2013/05/27/SQL-execution-order/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E7%AC%94%E8%AE%B0/2013/05/27/SQL-execution-order/</guid>
        
        <category>SQL</category>
        
        <category>基础知识</category>
        
        
        <category>笔记</category>
        
      </item>
    
      <item>
        <title>translation</title>
        <description>
</description>
        <pubDate>Fri, 01 Jan 2010 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E7%BF%BB%E8%AF%91/2010/01/01/translation/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E7%BF%BB%E8%AF%91/2010/01/01/translation/</guid>
        
        
        <category>翻译</category>
        
      </item>
    
      <item>
        <title>story</title>
        <description>
</description>
        <pubDate>Fri, 01 Jan 2010 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%B0%8F%E8%AF%B4/2010/01/01/story/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%B0%8F%E8%AF%B4/2010/01/01/story/</guid>
        
        
        <category>小说</category>
        
      </item>
    
      <item>
        <title>reproduce</title>
        <description>
</description>
        <pubDate>Fri, 01 Jan 2010 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E8%BD%AC%E8%BD%BD/2010/01/01/reproduce/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E8%BD%AC%E8%BD%BD/2010/01/01/reproduce/</guid>
        
        
        <category>转载</category>
        
      </item>
    
      <item>
        <title>original</title>
        <description>
</description>
        <pubDate>Fri, 01 Jan 2010 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%8E%9F%E5%88%9B/2010/01/01/original/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%8E%9F%E5%88%9B/2010/01/01/original/</guid>
        
        
        <category>原创</category>
        
      </item>
    
      <item>
        <title>Upsource</title>
        <description>
</description>
        <pubDate>Fri, 01 Jan 2010 20:00:00 +0800</pubDate>
        <link>https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2010/01/01/develop-tool/</link>
        <guid isPermaLink="true">https://minicool.github.io//%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/2010/01/01/develop-tool/</guid>
        
        <category>JetBrains</category>
        
        
        <category>开发工具</category>
        
      </item>
    
  </channel>
</rss>
